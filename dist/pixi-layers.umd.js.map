{"version":3,"file":"pixi-layers.umd.js","sources":["../src/DisplayMixin.ts","../src/RendererMixin.ts","../src/Group.ts","../src/Stage.ts","../src/index.ts"],"sourcesContent":["import { DisplayObject, Container } from '@pixi/display';\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function generateLayerContainerRenderMethod(originalRender: any)\n{\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    return function render(renderer: any): void\n    {\n        if (this._activeParentLayer && this._activeParentLayer !== renderer._activeLayer)\n        {\n            return;\n        }\n\n        if (!this.visible)\n        {\n            this.displayOrder = 0;\n\n            return;\n        }\n\n        this.displayOrder = renderer.incDisplayOrder();\n\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        renderer._activeLayer = null;\n        originalRender.call(this, renderer);\n        renderer._activeLayer = this._activeParentLayer;\n    };\n}\n\n// special case - container render method, because we want it to be faster\nfunction containerRender(renderer: any): void\n{\n    if (this._activeParentLayer && this._activeParentLayer !== renderer._activeLayer)\n    {\n        return;\n    }\n\n    if (!this.visible)\n    {\n        this.displayOrder = 0;\n\n        return;\n    }\n\n    this.displayOrder = renderer.incDisplayOrder();\n\n    // if the object is not visible or the alpha is 0 then no need to render this element\n    if (this.worldAlpha <= 0 || !this.renderable)\n    {\n        return;\n    }\n\n    renderer._activeLayer = null;\n    this.containerRenderWebGL(renderer);\n    renderer._activeLayer = this._activeParentLayer;\n}\n\nexport function applyDisplayMixin(): void\n{\n    if (DisplayObject.prototype.displayOrder !== undefined)\n    {\n        return;\n    }\n\n    (Object as any).assign(DisplayObject.prototype, {\n        parentLayer: null,\n        _activeParentLayer: null,\n        parentGroup: null,\n        zOrder: 0,\n        zIndex: 0,\n        updateOrder: 0,\n        displayOrder: 0,\n        layerableChildren: true,\n        isLayer: false\n    });\n\n    const ContainerProto = Container.prototype as any;\n\n    ContainerProto.containerRenderWebGL = ContainerProto.render;\n    ContainerProto.render = containerRender;\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function applyContainerRenderMixin(CustomRenderContainer: any): void\n{\n    if (CustomRenderContainer.originalRenderWebGL)\n    {\n        return;\n    }\n\n    CustomRenderContainer.originalRenderWebGL = CustomRenderContainer.render;\n    CustomRenderContainer.render = generateLayerContainerRenderMethod(CustomRenderContainer.render);\n\n    if (CustomRenderContainer.renderCanvas)\n    {\n        CustomRenderContainer.originalRenderWebGL = CustomRenderContainer.renderCanvas;\n        CustomRenderContainer.renderCanvas = generateLayerContainerRenderMethod(CustomRenderContainer.renderCanvas);\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function applyParticleMixin(ParticleContainer: any): void\n{\n    ParticleContainer.prototype.layerableChildren = false;\n    this.applyRenderMixing(ParticleContainer);\n}\n","import { IRenderableObject, IRendererRenderOptions, Renderer } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { LayersTreeSearch } from './LayersTreeSearch';\nimport { generateLayerContainerRenderMethod } from './DisplayMixin';\n\nimport type { Stage } from './Stage';\nimport type { Layer } from './Layer';\n\n/**\n * Mixin applied on {@link PIXI.Renderer} when using @pixi/layers.\n */\nexport interface ILayeredRenderer\n{\n    _lastDisplayOrder: 0;\n    _activeLayer: Layer;\n    incDisplayOrder(): number;\n    _oldRender(displayObject: IRenderableObject, options?: IRendererRenderOptions): void;\n}\n\n/** @internal */\nfunction generateLayerRendererMethod(_oldRender: any)\n{\n    return function render(displayObject: IRenderableObject, options: any, arg1?: any, arg2?: any, arg3?: any)\n    {\n        if (!options || (!options.renderTexture && !options.baseTexture))\n        {\n            this._lastDisplayOrder = 0;\n        }\n        this._activeLayer = null;\n\n        if ((displayObject as Stage).isStage)\n        {\n            (displayObject as Stage).updateStage();\n        }\n        if (this.plugins.interaction && !this.plugins.interaction.search.worksWithLayers)\n        {\n            this.plugins.interaction.search = new LayersTreeSearch();\n        }\n\n        _oldRender.call(this, displayObject, options, arg1, arg2, arg3);\n    };\n}\n\n/**\n * Mixes {@link ILayeredRenderer} into {@link PIXI.Renderer}.\n *\n * This is automatically done on importing @pixi/layers.\n */\nexport function applyRendererMixin(rendererClass: typeof Renderer)\n{\n    const RendererProto = rendererClass.prototype as (Renderer & Partial<ILayeredRenderer>);\n\n    // Skip if mixin already applied.\n    if (RendererProto._oldRender)\n    {\n        return;\n    }\n\n    Object.assign(RendererProto, {\n        _lastDisplayOrder: 0,\n        _activeLayer: null,\n        incDisplayOrder()\n        {\n            return ++this._lastDisplayOrder;\n        },\n        _oldRender: Renderer.prototype.render,\n    });\n\n    RendererProto._oldRender = RendererProto.render;\n    RendererProto.render = generateLayerRendererMethod(RendererProto.render);\n}\n\n/**\n * Mixes renderer mixin + container mixin for canvas.\n *\n * If you are using PixiJS' canvas renderer, you'll need to invoke this manually.\n *\n * @example\n * import { CanvasRenderer } from '@pixi/canvas-renderer';\n * import { applyCanvasMixin } from '@pixi/layers';\n *\n * applyCanvasMixin(CanvasRenderer);\n */\nexport function applyCanvasMixin(canvasRenderClass: any): void\n{\n    if (!canvasRenderClass)\n    {\n        // eslint-disable-next-line max-len,no-console\n        console.log('@pixi/layers: Canvas mixin was called with empty parameter. Are you sure that you even need this line?');\n\n        return;\n    }\n\n    applyRendererMixin(canvasRenderClass);\n\n    const ContainerProto = Container.prototype as any;\n\n    if (ContainerProto.containerRenderCanvas)\n    {\n        return;\n    }\n\n    ContainerProto.containerRenderCanvas = ContainerProto.renderCanvas;\n    ContainerProto.renderCanvas = generateLayerContainerRenderMethod(ContainerProto.renderCanvas);\n}\n\n","import * as utils from '@pixi/utils';\n\nimport type { DisplayObject } from '@pixi/display';\nimport type { Layer } from './Layer';\nimport type { Stage } from './Stage';\n\n/**\n * A context for z-ordering {@link PIXI.DisplayObject}s within the same {@link Layer}.\n */\nexport class Group extends utils.EventEmitter\n{\n    static _layerUpdateId = 0;\n\n    /** See {@link Layer#useRenderTexture} */\n    public useRenderTexture = false;\n\n    /** See {@link Layer#useDoubleBuffer} */\n    public useDoubleBuffer = false;\n\n    /**\n     * Groups with a non-zero sort priority are sorted first.\n     *\n     * Unsure of the exact purpose yet :)\n     */\n    public sortPriority = 0;\n\n    /** See {@link Layer#clearColor} */\n    public clearColor : ArrayLike<number> = new Float32Array([0, 0, 0, 0]);\n\n    // TODO: handle orphan groups\n    // TODO: handle groups that don't want to be drawn in parent\n    canDrawWithoutLayer = false;\n    canDrawInParentStage = true;\n\n    /** Default zIndex value for layers that are created with this Group */\n    public zIndex: number;\n\n    /** Enabling sorting objects within this group by {@link PIXI.DisplayObject#zIndex zIndex}. */\n    public enableSort: boolean;\n\n    private _activeLayer: Layer = null;\n    private _activeStage: Stage = null;\n    /** @private */\n    _activeChildren: Array<DisplayObject> = [];\n    private _lastUpdateId = -1;\n\n    /**\n     * @param zIndex - The z-index for the entire group.\n     * @param sorting - This will enable sorting by z-order. You can also pass a callback that will assign\n     *  the z-index _before_ sorting. This is useful, for example, when you want to sort by \"y\" - the callback\n     *  can then set the {@link PIXI.DisplayObject#zOrder zOrder} to the y-coordinate. This callback is invoked\n     *  as an event-listener to the {@link Group#sort} event.\n     */\n    constructor(zIndex: number, sorting: boolean | ((displayObject: DisplayObject) => void))\n    {\n        super();\n\n        this.zIndex = zIndex || 0;\n        this.enableSort = !!sorting;\n\n        if (typeof sorting === 'function')\n        {\n            this.on('sort', sorting);\n        }\n    }\n\n    doSort(layer: Layer, sorted: Array<DisplayObject>): void\n    {\n        if ((this.listeners as any)('sort', true))\n        {\n            for (let i = 0; i < sorted.length; i++)\n            {\n                this.emit('sort', sorted[i]);\n            }\n        }\n\n        sorted.sort(Group.compareZIndex);\n    }\n\n    private static compareZIndex(a: DisplayObject, b: DisplayObject): number\n    {\n        if (a.zOrder < b.zOrder)\n        {\n            return -1;\n        }\n        if (a.zOrder > b.zOrder)\n        {\n            return 1;\n        }\n\n        return a.updateOrder - b.updateOrder;\n    }\n\n    /**\n     * clears temporary variables\n     */\n    private clear(): void\n    {\n        this._activeLayer = null;\n        this._activeStage = null;\n        this._activeChildren.length = 0;\n    }\n\n    /**\n     * Resolve a child {@link PIXI.DisplayObject} that is set to be in this group.\n     *\n     * This is an **internal** method.\n     *\n     * @see Stage#updateStage\n     */\n    _resolveChildDisplayObject(stage: Stage, displayObject: DisplayObject): void\n    {\n        this.check(stage);\n        displayObject._activeParentLayer = this._activeLayer;\n\n        if (this._activeLayer)\n        {\n            this._activeLayer._activeChildren.push(displayObject);\n        }\n        else\n        {\n            this._activeChildren.push(displayObject);\n        }\n    }\n\n    /**\n     * Resolve the layer rendering this group of {@link DisplayObject display objects}.\n     *\n     * This is an **internal** method.\n     *\n     * @see Layer#_onBeginLayerSubtreeTraversal\n     */\n    _resolveLayer(stage: Stage, layer: Layer): void\n    {\n        this.check(stage);\n\n        if (this._activeLayer)\n        {\n            Group.conflict();\n        }\n\n        this._activeLayer = layer;\n        this._activeStage = stage;\n    }\n\n    private check(stage: Stage): void\n    {\n        if (this._lastUpdateId < Group._layerUpdateId)\n        {\n            this._lastUpdateId = Group._layerUpdateId;\n            this.clear();\n            this._activeStage = stage;\n        }\n        else if (this.canDrawInParentStage)\n        {\n            let current = this._activeStage;\n\n            while (current && current !== stage)\n            {\n                current = current._activeParentStage;\n            }\n            this._activeStage = current;\n            if (current === null)\n            {\n                this.clear();\n            }\n        }\n    }\n\n    private static _lastLayerConflict = 0;\n\n    /** Log a conflict that occurs when multiple layers render the same group. */\n    private static conflict(): void\n    {\n        if (Group._lastLayerConflict + 5000 < Date.now())\n        {\n            Group._lastLayerConflict = Date.now();\n            // eslint-disable-next-line max-len,no-console\n            console.log(`@pixi/layers found two layers with the same group in one stage - that's not healthy. Please place a breakpoint here and debug it`);\n        }\n    }\n\n    /**\n     * Fired for each {@link DisplayObject} in this group, right before they are sorted.\n     *\n     * @event sort\n     * @param {PIXI.DisplayObject} object - The object that will be sorted.\n     */\n}\n","import { Container, DisplayObject } from '@pixi/display';\nimport { Layer } from './Layer';\nimport { Group } from './Group';\n\n/**\n * The {@link Stage stage} manages all the layers in its scene tree.\n *\n *\n */\nexport class Stage extends Layer\n{\n    static _updateOrderCounter = 0;\n\n    /** Flags that this is a {@link Stage stage}! */\n    public readonly isStage = true;\n\n    _tempGroups: Array<DisplayObject> = [];\n\n    /**\n     * Found layers\n     */\n    _activeLayers: Array<Layer> = [];\n\n    _activeParentStage: Stage = null;\n\n    /**\n     * clears all display lists that were used in last rendering session\n     * please clear it when you stop using this displayList, otherwise you may have problems with GC in some cases\n     */\n    clear(): void\n    {\n        this._activeLayers.length = 0;\n        this._tempGroups.length = 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    destroy(options?: any): void\n    {\n        this.clear();\n        super.destroy(options);\n    }\n\n    /**\n     * This should be called before rendering for resolving items in the scene tree to their {@link Layer layers}.\n     *\n     * If your scene's root is a {@link Stage}, then the {@link ILayerRenderer} mixin will automatically\n     * call it.\n     */\n    updateStage(): void\n    {\n        this._activeParentStage = null;\n        Group._layerUpdateId++;\n        this._updateStageInner();\n    }\n\n    private updateAsChildStage(stage: Stage): void\n    {\n        this._activeParentStage = stage;\n        Stage._updateOrderCounter = 0;\n        this._updateStageInner();\n    }\n\n    private _updateStageInner(): void\n    {\n        this.clear();\n        this._addRecursive(this);\n        const layers = this._activeLayers;\n\n        for (let i = 0; i < layers.length; i++)\n        {\n            const layer = layers[i];\n\n            if (layer.group.sortPriority)\n            {\n                layer._onEndLayerSubtreeTraversal();\n                const sorted = layer._sortedChildren;\n\n                for (let j = 0; j < sorted.length; j++)\n                {\n                    this._addRecursiveChildren(sorted[j]);\n                }\n            }\n        }\n\n        for (let i = 0; i < layers.length; i++)\n        {\n            const layer = layers[i];\n\n            if (!layer.group.sortPriority)\n            {\n                layer._onEndLayerSubtreeTraversal();\n            }\n        }\n    }\n\n    private _addRecursive(displayObject: DisplayObject): void\n    {\n        if (!displayObject.visible)\n        {\n            return;\n        }\n\n        if ((displayObject as any).isLayer)\n        {\n            const layer = displayObject as any as Layer;\n\n            this._activeLayers.push(layer);\n            layer._onBeginLayerSubtreeTraversal(this);\n        }\n\n        if (displayObject !== this && (displayObject as any).isStage)\n        {\n            const stage = displayObject as Stage;\n\n            stage.updateAsChildStage(this);\n\n            return;\n        }\n\n        let group = displayObject.parentGroup;\n\n        if (group)\n        {\n            group._resolveChildDisplayObject(this, displayObject);\n        }\n        const layer = displayObject.parentLayer;\n\n        if (layer)\n        {\n            group = layer.group;\n            group._resolveChildDisplayObject(this, displayObject);\n        }\n\n        displayObject.updateOrder = ++Stage._updateOrderCounter;\n        if (displayObject.alpha <= 0 || !displayObject.renderable\n            || !displayObject.layerableChildren\n            || (group && group.sortPriority))\n        {\n            return;\n        }\n\n        const children = (displayObject as Container).children;\n\n        if (children && children.length)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._addRecursive(children[i]);\n            }\n        }\n    }\n\n    private _addRecursiveChildren(displayObject: DisplayObject): void\n    {\n        if (displayObject.alpha <= 0 || !displayObject.renderable\n            || !displayObject.layerableChildren)\n        {\n            return;\n        }\n        const children = (displayObject as Container).children;\n\n        if (children && children.length)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._addRecursive(children[i]);\n            }\n        }\n    }\n}\n","/* eslint-disable spaced-comment */\n/// <reference path=\"../global.d.ts\" />\n\nimport { applyDisplayMixin, applyContainerRenderMixin, applyParticleMixin } from './DisplayMixin';\nimport { applyRendererMixin, applyCanvasMixin, ILayeredRenderer } from './RendererMixin';\nimport { Renderer } from '@pixi/core';\n\nexport * from './Stage';\nexport * from './Layer';\nexport * from './Group';\n\nexport { applyDisplayMixin, applyCanvasMixin, applyContainerRenderMixin, applyRendererMixin, applyParticleMixin };\nexport { ILayeredRenderer };\n\napplyDisplayMixin();\napplyRendererMixin(Renderer);\n\n/**\n * The {@link Group group} in which this display object should be rendered.\n *\n * This is provided by **@pixi/layers**.\n * @member PIXI.DisplayObject#parentGroup\n */\n\n/**\n * The {@link Layer layer} in which this display object should be rendered; don't set this if you're\n * using {@link PIXI.DisplayObject#parentLayer}.\n *\n * This is provided by **@pixi/layers**.\n *\n * @member PIXI.DisplayObject#parentLayer\n */\n\n/**\n * Objects in a {@link Group group} are sorted by z-order. This can be used alongside PixiJS' built-in {@link PIXI.DisplayObject#zIndex zIndex}.\n *\n * If you use both {@code zIndex} and {@code zOrder}, objects will first be sorted by z-index and then @pixi/layers will\n * sort by z-order.\n *\n * This is provided by **@pixi/layers**.\n *\n * @member PIXI.DisplayObject#zOrder\n */\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAgCA;IAGA;;;;;;;;;;;;;;;IAyBA;;;;;;;;;;;;;;;;;;;IAyBA;;;;;;;;;;;IAkBA;;;;IAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC1FA;;;;;;;;;;;;;;IAqBA;;;;;;;;;;;;;;;;IA6BA;;;;;;;;;;;;;IAkCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC7FW;IA8JQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC9JR;;ICGX;IACA;;;;;;;;;;;;;;;;;;;;;"}