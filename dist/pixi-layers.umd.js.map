{"version":3,"file":"pixi-layers.umd.js","sources":["../src/DisplayMixin.ts","../src/RendererMixin.ts","../src/Group.ts","../src/Layer.ts","../src/Stage.ts","../src/index.ts"],"sourcesContent":["import { DisplayObject, Container } from '@pixi/display';\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function generateLayerContainerRenderMethod(originalRender: any)\r\n{\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    return function render(renderer: any): void\r\n    {\r\n        if (this._activeParentLayer && this._activeParentLayer !== renderer._activeLayer)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (!this.visible)\r\n        {\r\n            this.displayOrder = 0;\r\n\r\n            return;\r\n        }\r\n\r\n        this.displayOrder = renderer.incDisplayOrder();\r\n\r\n        // if the object is not visible or the alpha is 0 then no need to render this element\r\n        if (this.worldAlpha <= 0 || !this.renderable)\r\n        {\r\n            return;\r\n        }\r\n\r\n        renderer._activeLayer = null;\r\n        originalRender.call(this, renderer);\r\n        renderer._activeLayer = this._activeParentLayer;\r\n    };\r\n}\r\n\r\n// special case - container render method, because we want it to be faster\r\nfunction containerRender(renderer: any): void\r\n{\r\n    if (this._activeParentLayer && this._activeParentLayer !== renderer._activeLayer)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!this.visible)\r\n    {\r\n        this.displayOrder = 0;\r\n\r\n        return;\r\n    }\r\n\r\n    this.displayOrder = renderer.incDisplayOrder();\r\n\r\n    // if the object is not visible or the alpha is 0 then no need to render this element\r\n    if (this.worldAlpha <= 0 || !this.renderable)\r\n    {\r\n        return;\r\n    }\r\n\r\n    renderer._activeLayer = null;\r\n    this.containerRenderWebGL(renderer);\r\n    renderer._activeLayer = this._activeParentLayer;\r\n}\r\n\r\nexport function applyDisplayMixin(): void\r\n{\r\n    if (DisplayObject.prototype.displayOrder !== undefined)\r\n    {\r\n        return;\r\n    }\r\n\r\n    (Object as any).assign(DisplayObject.prototype, {\r\n        parentLayer: null,\r\n        _activeParentLayer: null,\r\n        parentGroup: null,\r\n        zOrder: 0,\r\n        zIndex: 0,\r\n        updateOrder: 0,\r\n        displayOrder: 0,\r\n        layerableChildren: true,\r\n        isLayer: false\r\n    });\r\n\r\n    const ContainerProto = Container.prototype as any;\r\n\r\n    ContainerProto.containerRenderWebGL = ContainerProto.render;\r\n    ContainerProto.render = containerRender;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function applyContainerRenderMixin(CustomRenderContainer: any): void\r\n{\r\n    if (CustomRenderContainer.originalRenderWebGL)\r\n    {\r\n        return;\r\n    }\r\n\r\n    CustomRenderContainer.originalRenderWebGL = CustomRenderContainer.render;\r\n    CustomRenderContainer.render = generateLayerContainerRenderMethod(CustomRenderContainer.render);\r\n\r\n    if (CustomRenderContainer.renderCanvas)\r\n    {\r\n        CustomRenderContainer.originalRenderWebGL = CustomRenderContainer.renderCanvas;\r\n        CustomRenderContainer.renderCanvas = generateLayerContainerRenderMethod(CustomRenderContainer.renderCanvas);\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function applyParticleMixin(ParticleContainer: any): void\r\n{\r\n    ParticleContainer.prototype.layerableChildren = false;\r\n    this.applyRenderMixing(ParticleContainer);\r\n}\r\n","import { IRenderableObject, IRendererRenderOptions, Renderer } from '@pixi/core';\r\nimport { Container, DisplayObject } from '@pixi/display';\r\nimport { LayersTreeSearch } from './LayersTreeSearch';\r\nimport { generateLayerContainerRenderMethod } from './DisplayMixin';\r\nimport type { Stage } from './Stage';\r\nimport type { Layer } from './Layer';\r\n\r\nexport interface ILayeredRenderer\r\n{\r\n    _lastDisplayOrder: 0;\r\n    _activeLayer: Layer;\r\n    incDisplayOrder(): number;\r\n    _oldRender(displayObject: IRenderableObject, options?: IRendererRenderOptions): void;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nfunction generateLayerRendererMethod(_oldRender: any)\r\n{\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    return function render(displayObject: DisplayObject, options: any, arg1: any, arg2: any, arg3: any)\r\n    {\r\n        if (!options || (!options.renderTexture && !options.baseTexture))\r\n        {\r\n            this._lastDisplayOrder = 0;\r\n        }\r\n        this._activeLayer = null;\r\n        if ((displayObject as Stage).isStage)\r\n        {\r\n            (displayObject as Stage).updateStage();\r\n        }\r\n        if (this.plugins.interaction && !this.plugins.interaction.search.worksWithLayers)\r\n        {\r\n            this.plugins.interaction.search = new LayersTreeSearch();\r\n        }\r\n        _oldRender.call(this, displayObject, options, arg1, arg2, arg3);\r\n    };\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function applyRendererMixin(rendererClass: any)\r\n{\r\n    const RendererProto = rendererClass.prototype;\r\n\r\n    if (RendererProto._oldRender)\r\n    {\r\n        return;\r\n    }\r\n\r\n    (Object as any).assign(RendererProto, {\r\n        _lastDisplayOrder: 0,\r\n        _activeLayer: null,\r\n        incDisplayOrder()\r\n        {\r\n            return ++this._lastDisplayOrder;\r\n        },\r\n        _oldRender: Renderer.prototype.render,\r\n    });\r\n\r\n    RendererProto._oldRender = RendererProto.render;\r\n    RendererProto.render = generateLayerRendererMethod(RendererProto.render);\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function applyCanvasMixin(canvasRenderClass: any): void\r\n{\r\n    if (!canvasRenderClass)\r\n    {\r\n        // eslint-disable-next-line max-len,no-console\r\n        console.log('@pixi/layers: Canvas mixin was called with empty parameter. Are you sure that you even need this line?');\r\n\r\n        return;\r\n    }\r\n\r\n    applyRendererMixin(canvasRenderClass);\r\n\r\n    const ContainerProto = Container.prototype as any;\r\n\r\n    if (ContainerProto.containerRenderCanvas)\r\n    {\r\n        return;\r\n    }\r\n    ContainerProto.containerRenderCanvas = ContainerProto.renderCanvas;\r\n    ContainerProto.renderCanvas = generateLayerContainerRenderMethod(ContainerProto.renderCanvas);\r\n}\r\n\r\n","/**\r\n * A shared component for multiple DisplayObject's allows to specify rendering order for them\r\n *\r\n * @class\r\n * @extends EventEmitter\r\n * @memberof PIXI\r\n * @param zIndex {number} z-index for display group\r\n * @param sorting {boolean | Function} if you need to sort elements inside, please provide function that will set displayObject.zOrder accordingly\r\n */\r\n\r\nimport { DisplayObject } from '@pixi/display';\r\nimport * as utils from '@pixi/utils';\r\nimport type { Layer } from './Layer';\r\nimport type { Stage } from './Stage';\r\n\r\nexport class Group extends utils.EventEmitter\r\n{\r\n    static _layerUpdateId = 0;\r\n\r\n    _activeLayer: Layer = null;\r\n\r\n    _activeStage: Stage = null;\r\n\r\n    _activeChildren: Array<DisplayObject> = [];\r\n\r\n    _lastUpdateId = -1;\r\n\r\n    useRenderTexture = false;\r\n    useDoubleBuffer = false;\r\n    sortPriority = 0;\r\n    clearColor : ArrayLike<number> = new Float32Array([0, 0, 0, 0]);\r\n\r\n    // TODO: handle orphan groups\r\n    // TODO: handle groups that don't want to be drawn in parent\r\n    canDrawWithoutLayer = false;\r\n    canDrawInParentStage = true;\r\n\r\n    /**\r\n     * default zIndex value for layers that are created with this Group\r\n     * @type {number}\r\n     */\r\n    zIndex = 0;\r\n\r\n    enableSort = false;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/ban-types\r\n    constructor(zIndex: number, sorting: boolean | Function)\r\n    {\r\n        super();\r\n\r\n        this.zIndex = zIndex;\r\n\r\n        this.enableSort = !!sorting;\r\n\r\n        if (typeof sorting === 'function')\r\n        {\r\n            this.on('sort', sorting as any);\r\n        }\r\n    }\r\n\r\n    doSort(layer: Layer, sorted: Array<DisplayObject>): void\r\n    {\r\n        if ((this.listeners as any)('sort', true))\r\n        {\r\n            for (let i = 0; i < sorted.length; i++)\r\n            {\r\n                this.emit('sort', sorted[i]);\r\n            }\r\n        }\r\n\r\n        sorted.sort(Group.compareZIndex);\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    static compareZIndex(a: DisplayObject, b: DisplayObject)\r\n    {\r\n        if (a.zOrder < b.zOrder)\r\n        {\r\n            return -1;\r\n        }\r\n        if (a.zOrder > b.zOrder)\r\n        {\r\n            return 1;\r\n        }\r\n\r\n        return a.updateOrder - b.updateOrder;\r\n    }\r\n\r\n    /**\r\n     * clears temporary variables\r\n     */\r\n    clear(): void\r\n    {\r\n        this._activeLayer = null;\r\n        this._activeStage = null;\r\n        this._activeChildren.length = 0;\r\n    }\r\n\r\n    /**\r\n     * used only by displayList before sorting takes place\r\n     */\r\n    addDisplayObject(stage: Stage, displayObject: DisplayObject): void\r\n    {\r\n        this.check(stage);\r\n        displayObject._activeParentLayer = this._activeLayer;\r\n        if (this._activeLayer)\r\n        {\r\n            this._activeLayer._activeChildren.push(displayObject);\r\n        }\r\n        else\r\n        {\r\n            this._activeChildren.push(displayObject);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * called when corresponding layer is found in current stage\r\n     * @param stage\r\n     * @param layer\r\n     */\r\n    foundLayer(stage: Stage, layer: Layer): void\r\n    {\r\n        this.check(stage);\r\n        // eslint-disable-next-line eqeqeq,no-eq-null\r\n        if (this._activeLayer != null)\r\n        {\r\n            Group.conflict();\r\n        }\r\n        this._activeLayer = layer;\r\n        this._activeStage = stage;\r\n    }\r\n\r\n    /**\r\n     * called after stage finished the work\r\n     * @param stage\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    foundStage(stage: Stage): void\r\n    {\r\n        if (!this._activeLayer && !this.canDrawInParentStage)\r\n        {\r\n            this.clear();\r\n        }\r\n    }\r\n\r\n    check(stage: Stage): void\r\n    {\r\n        if (this._lastUpdateId < Group._layerUpdateId)\r\n        {\r\n            this._lastUpdateId = Group._layerUpdateId;\r\n            this.clear();\r\n            this._activeStage = stage;\r\n        }\r\n        else if (this.canDrawInParentStage)\r\n        {\r\n            let current = this._activeStage;\r\n\r\n            while (current && current !== stage)\r\n            {\r\n                current = current._activeParentStage;\r\n            }\r\n            this._activeStage = current;\r\n            if (current === null)\r\n            {\r\n                this.clear();\r\n            }\r\n        }\r\n    }\r\n\r\n    static _lastLayerConflict = 0;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    static conflict()\r\n    {\r\n        if (Group._lastLayerConflict + 5000 < Date.now())\r\n        {\r\n            Group._lastLayerConflict = Date.now();\r\n            // eslint-disable-next-line max-len,no-console\r\n            console.log(`PIXI-display plugin found two layers with the same group in one stage - that's not healthy. Please place a breakpoint here and debug it`);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Created by ivanp on 29.01.2017.\r\n */\r\n\r\nimport { RenderTexture, Renderer } from '@pixi/core';\r\nimport { Rectangle } from '@pixi/math';\r\nimport { settings } from '@pixi/settings';\r\nimport { Container, DisplayObject } from '@pixi/display';\r\nimport { Group } from './Group';\r\nimport type { Stage } from './Stage';\r\nimport type { ILayeredRenderer } from './RendererMixin';\r\n\r\nexport class LayerTextureCache\r\n{\r\n    constructor(public layer: Layer)\r\n    {\r\n    }\r\n\r\n    renderTexture: RenderTexture = null;\r\n    doubleBuffer: Array<RenderTexture> = null;\r\n    currentBufferIndex = 0;\r\n    _tempRenderTarget: RenderTexture = null;\r\n    _tempRenderTargetSource = new Rectangle();\r\n\r\n    initRenderTexture(renderer?: Renderer): void\r\n    {\r\n        const width = renderer ? renderer.screen.width : 100;\r\n        const height = renderer ? renderer.screen.height : 100;\r\n        const resolution = renderer ? renderer.resolution : settings.RESOLUTION;\r\n\r\n        this.renderTexture = RenderTexture.create({ width, height, resolution });\r\n\r\n        if (this.layer.group.useDoubleBuffer)\r\n        {\r\n            this.doubleBuffer = [\r\n                RenderTexture.create({ width, height, resolution }),\r\n                RenderTexture.create({ width, height, resolution })\r\n            ];\r\n        }\r\n    }\r\n\r\n    getRenderTexture(): RenderTexture\r\n    {\r\n        if (!this.renderTexture)\r\n        {\r\n            this.initRenderTexture();\r\n        }\r\n\r\n        return this.renderTexture;\r\n    }\r\n\r\n    pushTexture(renderer: Renderer): void\r\n    {\r\n        // TODO: take not screen, but offset screen, in case there's matrix transform\r\n        const screen = renderer.screen;\r\n\r\n        if (!this.renderTexture)\r\n        {\r\n            this.initRenderTexture(renderer);\r\n        }\r\n\r\n        const rt = this.renderTexture;\r\n        const group = this.layer.group;\r\n        const db = this.doubleBuffer;\r\n\r\n        if (rt.width !== screen.width\r\n            || rt.height !== screen.height\r\n            || rt.baseTexture.resolution !== renderer.resolution)\r\n        {\r\n            rt.baseTexture.resolution = renderer.resolution;\r\n            rt.resize(screen.width, screen.height);\r\n\r\n            if (db)\r\n            {\r\n                db[0].baseTexture.resolution = renderer.resolution;\r\n                db[0].resize(screen.width, screen.height);\r\n                db[1].baseTexture.resolution = renderer.resolution;\r\n                db[1].resize(screen.width, screen.height);\r\n            }\r\n        }\r\n\r\n        if (db)\r\n        {\r\n            db[0].framebuffer.multisample = rt.framebuffer.multisample;\r\n            db[1].framebuffer.multisample = rt.framebuffer.multisample;\r\n        }\r\n\r\n        this._tempRenderTarget = renderer.renderTexture.current;\r\n        this._tempRenderTargetSource.copyFrom(renderer.renderTexture.sourceFrame);\r\n\r\n        renderer.batch.flush();\r\n\r\n        if (group.useDoubleBuffer)\r\n        {\r\n            // double-buffer logic\r\n            let buffer = db[this.currentBufferIndex];\r\n\r\n            if (!(buffer.baseTexture as any)._glTextures[renderer.CONTEXT_UID])\r\n            {\r\n                renderer.renderTexture.bind(buffer, undefined, undefined);\r\n                renderer.texture.bind(buffer);\r\n                if (group.clearColor)\r\n                {\r\n                    renderer.renderTexture.clear(group.clearColor as any);\r\n                }\r\n            }\r\n            renderer.texture.unbind(rt.baseTexture);\r\n            (rt.baseTexture as any)._glTextures = (buffer.baseTexture as any)._glTextures;\r\n            (rt.baseTexture as any).framebuffer = (buffer.baseTexture as any).framebuffer;\r\n\r\n            buffer = db[1 - this.currentBufferIndex];\r\n            renderer.renderTexture.bind(buffer, undefined, undefined);\r\n        }\r\n        else\r\n        {\r\n            // simple logic\r\n            renderer.renderTexture.bind(rt, undefined, undefined);\r\n        }\r\n\r\n        if (group.clearColor)\r\n        {\r\n            renderer.renderTexture.clear(group.clearColor as any);\r\n        }\r\n\r\n        // fix for filters\r\n        const filterStack = renderer.filter.defaultFilterStack;\r\n\r\n        if (filterStack.length > 1)\r\n        {\r\n            filterStack[filterStack.length - 1].renderTexture = renderer.renderTexture.current;\r\n        }\r\n    }\r\n\r\n    popTexture(renderer: Renderer): void\r\n    {\r\n        renderer.batch.flush();\r\n        renderer.framebuffer.blit();\r\n        // switch filters back\r\n        const filterStack = renderer.filter.defaultFilterStack;\r\n\r\n        if (filterStack.length > 1)\r\n        {\r\n            filterStack[filterStack.length - 1].renderTexture = this._tempRenderTarget;\r\n        }\r\n        renderer.renderTexture.bind(this._tempRenderTarget, this._tempRenderTargetSource, undefined);\r\n        this._tempRenderTarget = null;\r\n\r\n        const rt = this.renderTexture;\r\n        const group = this.layer.group;\r\n        const db = this.doubleBuffer;\r\n\r\n        if (group.useDoubleBuffer)\r\n        {\r\n            renderer.texture.unbind(rt.baseTexture);\r\n            this.currentBufferIndex = 1 - this.currentBufferIndex;\r\n\r\n            const buffer = db[this.currentBufferIndex];\r\n\r\n            (rt.baseTexture as any)._glTextures = (buffer.baseTexture as any)._glTextures;\r\n            (rt.baseTexture as any).framebuffer = (buffer.baseTexture as any).framebuffer;\r\n        }\r\n    }\r\n\r\n    destroy(): void\r\n    {\r\n        if (this.renderTexture)\r\n        {\r\n            this.renderTexture.destroy();\r\n            if (this.doubleBuffer)\r\n            {\r\n                this.doubleBuffer[0].destroy(true);\r\n                this.doubleBuffer[1].destroy(true);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport class Layer extends Container\r\n{\r\n    constructor(group: Group = null)\r\n    {\r\n        super();\r\n        // eslint-disable-next-line eqeqeq,no-eq-null\r\n        if (group != null)\r\n        {\r\n            this.group = group;\r\n            this.zIndex = group.zIndex;\r\n        }\r\n        else\r\n        {\r\n            this.group = new Group(0, false);\r\n        }\r\n        this._tempChildren = this.children;\r\n    }\r\n\r\n    isLayer = true;\r\n    group: Group = null;\r\n    _activeChildren: Array<DisplayObject> = [];\r\n    _tempChildren: Array<DisplayObject> = null;\r\n    _activeStageParent: Stage = null;\r\n    _sortedChildren: Array<DisplayObject> = [];\r\n    _tempLayerParent: Layer = null;\r\n\r\n    textureCache: LayerTextureCache;\r\n    insertChildrenBeforeActive = true;\r\n    insertChildrenAfterActive = true;\r\n\r\n    beginWork(stage: Stage): void\r\n    {\r\n        const active = this._activeChildren;\r\n\r\n        this._activeStageParent = stage;\r\n        this.group.foundLayer(stage, this);\r\n        const groupChildren = this.group._activeChildren;\r\n\r\n        active.length = 0;\r\n        for (let i = 0; i < groupChildren.length; i++)\r\n        {\r\n            groupChildren[i]._activeParentLayer = this;\r\n            active.push(groupChildren[i]);\r\n        }\r\n        groupChildren.length = 0;\r\n    }\r\n\r\n    endWork(): void\r\n    {\r\n        const children = this.children;\r\n        const active = this._activeChildren;\r\n        const sorted = this._sortedChildren;\r\n\r\n        for (let i = 0; i < active.length; i++)\r\n        {\r\n            this.emit('display', active[i]);\r\n        }\r\n\r\n        sorted.length = 0;\r\n        if (this.insertChildrenBeforeActive)\r\n        {\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                sorted.push(children[i]);\r\n            }\r\n        }\r\n        for (let i = 0; i < active.length; i++)\r\n        {\r\n            sorted.push(active[i]);\r\n        }\r\n        if (!this.insertChildrenBeforeActive\r\n            && this.insertChildrenAfterActive)\r\n        {\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                sorted.push(children[i]);\r\n            }\r\n        }\r\n\r\n        if (this.group.enableSort)\r\n        {\r\n            this.doSort();\r\n        }\r\n    }\r\n\r\n    get useRenderTexture(): boolean\r\n    {\r\n        return this.group.useRenderTexture;\r\n    }\r\n\r\n    set useRenderTexture(value: boolean)\r\n    {\r\n        this.group.useRenderTexture = value;\r\n    }\r\n\r\n    get useDoubleBuffer(): boolean\r\n    {\r\n        return this.group.useDoubleBuffer;\r\n    }\r\n\r\n    set useDoubleBuffer(value: boolean)\r\n    {\r\n        this.group.useDoubleBuffer = value;\r\n    }\r\n\r\n    get clearColor(): ArrayLike<number>\r\n    {\r\n        return this.group.clearColor;\r\n    }\r\n\r\n    set clearColor(value: ArrayLike<number>)\r\n    {\r\n        this.group.clearColor = value;\r\n    }\r\n\r\n    get sortPriority(): number\r\n    {\r\n        return this.group.sortPriority;\r\n    }\r\n\r\n    set sortPriority(value: number)\r\n    {\r\n        this.group.sortPriority = value;\r\n    }\r\n\r\n    getRenderTexture(): RenderTexture\r\n    {\r\n        if (!this.textureCache)\r\n        {\r\n            this.textureCache = new LayerTextureCache(this);\r\n        }\r\n\r\n        return this.textureCache.getRenderTexture();\r\n    }\r\n\r\n    /**\r\n     * you can override this method for this particular layer, if you want\r\n     */\r\n    doSort(): void\r\n    {\r\n        this.group.doSort(this, this._sortedChildren);\r\n    }\r\n\r\n    _preRender(renderer: ILayeredRenderer): boolean\r\n    {\r\n        // eslint-disable-next-line eqeqeq\r\n        if (this._activeParentLayer && this._activeParentLayer != renderer._activeLayer)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (!this.visible)\r\n        {\r\n            this.displayOrder = 0;\r\n\r\n            return false;\r\n        }\r\n\r\n        this.displayOrder = renderer.incDisplayOrder();\r\n\r\n        // if the object is not visible or the alpha is 0 then no need to render this element\r\n        if (this.worldAlpha <= 0 || !this.renderable)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        // we are making a hack with swapping children, it can go wrong easily\r\n        // this is special \"recover\" if that allows stage to recover just after failed frame\r\n\r\n        if (this.children !== this._sortedChildren\r\n            && this._tempChildren !== this.children)\r\n        {\r\n            this._tempChildren = this.children;\r\n        }\r\n\r\n        // just a temporary feature - getBounds() for filters will work with that\r\n        // TODO: make a better hack for getBounds()\r\n\r\n        (this as any)._boundsID++;\r\n        (this as any).children = this._sortedChildren;\r\n\r\n        this._tempLayerParent = renderer._activeLayer;\r\n        renderer._activeLayer = this;\r\n\r\n        return true;\r\n    }\r\n\r\n    _postRender(renderer: ILayeredRenderer): void\r\n    {\r\n        (this as any).children = this._tempChildren;\r\n        renderer._activeLayer = this._tempLayerParent;\r\n        this._tempLayerParent = null;\r\n    }\r\n\r\n    render(renderer: Renderer): void\r\n    {\r\n        if (!this._preRender(renderer as any))\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this.group.useRenderTexture)\r\n        {\r\n            if (!this.textureCache)\r\n            {\r\n                this.textureCache = new LayerTextureCache(this);\r\n            }\r\n            this.textureCache.pushTexture(renderer);\r\n        }\r\n\r\n        this.containerRenderWebGL(renderer);\r\n        this._postRender(renderer as any);\r\n\r\n        if (this.group.useRenderTexture)\r\n        {\r\n            this.textureCache.popTexture(renderer);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    destroy(options?: any): void\r\n    {\r\n        if (this.textureCache)\r\n        {\r\n            this.textureCache.destroy();\r\n            this.textureCache = null;\r\n        }\r\n        super.destroy(options);\r\n    }\r\n}\r\n\r\n(Layer.prototype as any).renderCanvas = function renderCanvas(renderer: ILayeredRenderer)\r\n{\r\n    if (this._preRender(renderer))\r\n    {\r\n        this.containerRenderCanvas(renderer);\r\n        this._postRender(renderer);\r\n    }\r\n};\r\n","/**\r\n * Container for layers\r\n *\r\n */\r\nimport { Container, DisplayObject } from '@pixi/display';\r\nimport { Layer } from './Layer';\r\nimport { Group } from './Group';\r\n\r\nexport class Stage extends Layer\r\n{\r\n    static _updateOrderCounter = 0;\r\n\r\n    isStage = true;\r\n\r\n    _tempGroups: Array<DisplayObject> = [];\r\n\r\n    /**\r\n     * Found layers\r\n     */\r\n    _activeLayers: Array<Layer> = [];\r\n\r\n    _activeParentStage: Stage = null;\r\n\r\n    /**\r\n     * clears all display lists that were used in last rendering session\r\n     * please clear it when you stop using this displayList, otherwise you may have problems with GC in some cases\r\n     */\r\n    clear(): void\r\n    {\r\n        this._activeLayers.length = 0;\r\n        this._tempGroups.length = 0;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    destroy(options?: any): void\r\n    {\r\n        this.clear();\r\n        super.destroy(options);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param displayObject {PIXI.DisplayObject} container that we are adding to Stage\r\n     * @private\r\n     */\r\n    _addRecursive(displayObject: DisplayObject): void\r\n    {\r\n        if (!displayObject.visible)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if ((displayObject as any).isLayer)\r\n        {\r\n            const layer = displayObject as any as Layer;\r\n\r\n            this._activeLayers.push(layer);\r\n            layer.beginWork(this);\r\n        }\r\n\r\n        if (displayObject !== this && (displayObject as any).isStage)\r\n        {\r\n            const stage = displayObject as Stage;\r\n\r\n            stage.updateAsChildStage(this);\r\n\r\n            return;\r\n        }\r\n\r\n        // sometimes people put UNDEFINED in parentGroup or parentLayer\r\n        // that's why there is != instead of !==\r\n\r\n        let group = displayObject.parentGroup;\r\n\r\n        // eslint-disable-next-line eqeqeq,no-eq-null\r\n        if (group != null)\r\n        {\r\n            group.addDisplayObject(this, displayObject);\r\n        }\r\n        const layer = displayObject.parentLayer;\r\n\r\n        // eslint-disable-next-line eqeqeq,no-eq-null\r\n        if (layer != null)\r\n        {\r\n            group = layer.group;\r\n            group.addDisplayObject(this, displayObject);\r\n        }\r\n\r\n        displayObject.updateOrder = ++Stage._updateOrderCounter;\r\n        if (displayObject.alpha <= 0 || !displayObject.renderable\r\n            || !displayObject.layerableChildren\r\n            || (group && group.sortPriority))\r\n        {\r\n            return;\r\n        }\r\n\r\n        const children = (displayObject as Container).children;\r\n\r\n        if (children && children.length)\r\n        {\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                this._addRecursive(children[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    _addRecursiveChildren(displayObject: DisplayObject): void\r\n    {\r\n        if (displayObject.alpha <= 0 || !displayObject.renderable\r\n            || !displayObject.layerableChildren)\r\n        {\r\n            return;\r\n        }\r\n        const children = (displayObject as Container).children;\r\n\r\n        if (children && children.length)\r\n        {\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                this._addRecursive(children[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    _updateStageInner(): void\r\n    {\r\n        this.clear();\r\n        this._addRecursive(this);\r\n        const layers = this._activeLayers;\r\n\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            const layer = layers[i];\r\n\r\n            if (layer.group.sortPriority)\r\n            {\r\n                layer.endWork();\r\n                const sorted = layer._sortedChildren;\r\n\r\n                for (let j = 0; j < sorted.length; j++)\r\n                {\r\n                    this._addRecursiveChildren(sorted[j]);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            const layer = layers[i];\r\n\r\n            if (!layer.group.sortPriority)\r\n            {\r\n                layer.endWork();\r\n            }\r\n        }\r\n    }\r\n\r\n    updateAsChildStage(stage: Stage): void\r\n    {\r\n        this._activeParentStage = stage;\r\n        Stage._updateOrderCounter = 0;\r\n        this._updateStageInner();\r\n    }\r\n\r\n    updateStage(): void\r\n    {\r\n        this._activeParentStage = null;\r\n        Group._layerUpdateId++;\r\n        this._updateStageInner();\r\n    }\r\n}\r\n","/* eslint-disable spaced-comment */\r\n/// <reference path=\"../global.d.ts\" />\r\n\r\nimport { applyDisplayMixin, applyContainerRenderMixin, applyParticleMixin } from './DisplayMixin';\r\nimport { applyRendererMixin, applyCanvasMixin, ILayeredRenderer } from './RendererMixin';\r\nimport { Renderer } from '@pixi/core';\r\n\r\nexport * from './Stage';\r\nexport * from './Layer';\r\nexport * from './Group';\r\n\r\nexport { applyDisplayMixin, applyCanvasMixin, applyContainerRenderMixin, applyRendererMixin, applyParticleMixin };\r\nexport { ILayeredRenderer };\r\n\r\napplyDisplayMixin();\r\napplyRendererMixin(Renderer);\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAgCA;IAGA;;;;;;;;;;;;;;;IAyBA;;;;;;;;;;;;;;;;;;;IAyBA;;;;;;;;;;;IAkBA;;;;IAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC9FA;;;;;;;;;;;;;;IAoBA;;;;;;;;;;;;;;;;IAwBA;;;;;;;;;;;;;IAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IClEW;IAwJA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC+OV;;;;;IAOD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICrZW;;ICIX;IACA;;;;;;;;;;;;;;;;;;;;;"}